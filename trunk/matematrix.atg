#include <iostream>
#include <fstream>
#include <stack>
#include <string>
#include <wchar.h>
#include "symbolTable.h"
#include <tr1/unordered_map>

using namespace std;
using namespace std::tr1;

/*

codigo para tipos
0 int
1 float
2 string
3 boolean
4 complex
5 error
6 void
7 program

*/

COMPILER matematrix

//se declaran objetos de las clases
symbolTable st;
constTable ct;
Memoria MemGlobal;
Memoria MemTemp;
Memoria MemConst;
Memoria MemLoc;
Memoria MemPoint;


//variables globales que se usan en todo el progama
int // types
	  floats, integer, boolean, complexi, stringg;

int // operators
	  plus, minus, times, slash, diff, gtr, lss, gtreq, lsseq, eqeq, andop, orop, equ;

int // object kinds
	  var, def;

int // opcodes
	  ADD,  SUB,   MUL,   DIV,   EQU,  LSS, GTR, DIFF,
	  GTREQ, LSSEQ, EQEQ, ANDOP, OROP, RET, PRINT, RETURN,
	  GOTO, GOTOF, GOTOV, GOSUB, READ, ERA, PARAM, END,
	  PM, SQRT, POW, DIST, ECU, SIN, CSC, COS, COT, TAN, SEC,VERF;


//varibles temporales
int numproc, tipoactual,tipo_proc, cont_cuadruple, diract,asact, aux,k,arg,tipoarg,conti,contf,contb,conts,numdim,idArr, dimactual, templlave,tempbase, tempfor, llenar1,llenar2,llenar3,llenar4;  //Variables utilizadas para generar cuadruplos.

//variables que se usan para la generacion de cuadruplos de arreglos.
int *m;
int R;
int *ls;

//pilas
stack<int> PTipos;
stack<int> POperadores;
stack<int> POperandos;
stack<int> PSaltos;
stack<int> PDimensiones;
stack<wchar_t*>PFunciones;

// struct de cuadruplos 
typedef struct {
	int op;
	int opdo1;
	int opdo2;
	int res;
} cuadruplos;

//tabla de hashing en donde se meten los structs de los cuadruplos
unordered_map<int, cuadruplos> hasht;

//funcion del cubo semantico
int semantico(int a, int b , int c) {

int t;
			//	 +  -  *  /  <> >  < >= <= == and or =
int semanticCube[5][5][13] = {{ {0, 0, 0, 0, 3, 3, 3, 3, 3, 3, 5, 5, 0},
                                {1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 5, 5, 5},
   /*int*/                      {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5} },
                              { {1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 5, 5, 5},
   /*float*/                    {1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 5, 5, 1},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5} },
                              { {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
  /*string*/                    {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 3, 5, 5, 5, 3, 5, 5, 5, 2},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5} },
                              { {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
  /*bool*/                      {5, 5, 5, 5, 3, 5, 5, 5, 3, 5, 5, 5, 3},
                                {5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 3},
                                {5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 5, 5, 5} },
                              { {4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 5, 5, 5},
  /*complejo*/                  {4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5},
                                {4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 5, 5, 4} }};


t = semanticCube[a][b][c];
return t;
}

//funcion que rellena un cuadruplo
int rellenar(int a, int b) {
	if(hasht.find(a) != hasht.end()) {
		hasht[a].res = b;
	}
	
}

//las siguientes son funciones que se usan para generar cuadruplos particulares
int buildCruadruple(int op){
	int uno, dos, id1, id2, res, temp;
	dos = PTipos.top();
	PTipos.pop();
	uno = PTipos.top();
	PTipos.pop();
		
if(semantico(uno, dos, op) != 5 ) {	
	
	id2 = POperandos.top();
	POperandos.pop();
	id1 = POperandos.top();
	POperandos.pop();
	
	res = semantico(uno, dos, op);
		switch(res) {
			case 0:
				temp = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, res);
			break;
			case 1:
				temp = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, res);
			break;
			case 2:
				temp = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, res);
			break;
			case 3:
				temp = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, res);
			break;
			case 4:
				temp = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, res);
			break;
			default:
				cout << "Type mismatch" << endl;
		}
	cuadruplos x;
	x.op = op;
	x.opdo1 = id1;
	x.opdo2 = id2;
	x.res = temp;
	hasht[cont_cuadruple] = x;
	cont_cuadruple++;
	POperandos.push(temp);
	PTipos.push(res);
	POperadores.pop();
//cout << "pila tipos top " << PTipos.top() << endl;
	} else {
		cout << "Semantic error: Type mismatch" << endl;

	}
return 0;
}

int buildCruadruple2(int op){
	int uno, dos, id1, id2, res;
	//dos = PTipos.top();
	//PTipos.pop();
	//uno = PTipos.top();
	//PTipos.pop();

	//if( semantico(uno, dos, op) != 5 ) {	
	id2 = POperandos.top();
		POperandos.pop();
		id1 = -1;
		res = POperandos.top();
		POperandos.pop();
		cuadruplos x;
		x.op = op;
		x.opdo1 = id1;
		x.opdo2 = id2;
		x.res = res;
		hasht[cont_cuadruple] = x;
		cont_cuadruple++;
		POperadores.pop();
//	} else {
//		cout << "Semantic error: Type mismatch" << endl;

//	}
return 0;
}

/*
int buildCuadrupleR(int op, int a, int op2, int res){
	int uno, dos, id1, id2, res;
	dos = PTipos.top();
	PTipos.pop();
	uno = PTipos.top();
	PTipos.pop();

	if( semantico(uno, dos, op) != 5 ) {
		id2 = POperandos.top();
		POperandos.pop();
		id1 = -1;
		res = POperandos.top();
		POperandos.pop();
		cuadruplos x;
		x.op = op;
		x.opdo1 = id1;
		x.opdo2 = id2;
		x.res = res;
		hasht[cont_cuadruple] = x;
		cont_cuadruple++;
		POperadores.pop();
	} else {
		cout << "Semantic error: Type mismatch" << endl;

	}
return 0;
}
*/
int buildCuadruple3(){
int res, aux;	
aux = PTipos.top();
PTipos.pop();
cout << "El valor de aux es: " << aux << endl;
	if(aux == 3 ) {
		res = POperandos.top();
		POperandos.pop();
cout << "1er cuadruplo" << cont_cuadruple << endl;
		cuadruplos x;
		x.op = GOTOF;
		x.opdo1 = res;
		x.opdo2 = -1;
		x.res = -1;
		hasht[cont_cuadruple] = x;
		cont_cuadruple++;
cout << "antes " << PSaltos.top() << endl;
		PSaltos.push((cont_cuadruple-1));
cout << "despues " << PSaltos.top() << endl;
	} else {
		cout << "Semantic error: Type mismatch" << endl;

	}
return 0;
}

int buildCuadrupleWhile(){
	int falso = PSaltos.top();
	PSaltos.pop();
	int retorno = PSaltos.top();
	PSaltos.pop();
cout << "2ndo cuadruplo" << cont_cuadruple << endl;
	cuadruplos x;
	x.op = GOTO;
	x.opdo1 = -1;
	x.opdo2 = -1;
	x.res = retorno;
	hasht[cont_cuadruple] = x;
	cont_cuadruple++;
	rellenar(falso,cont_cuadruple);
return 0;
}

int buildCuadruple4(int a){
	int id2, res;
		id2 = -1;
		POperandos.pop();
		cuadruplos x;
		x.op = GOTOF;
		x.opdo1 = a;
		x.opdo2 = id2;
		x.res = -1;
		hasht[cont_cuadruple] = x;
		cont_cuadruple++;
return 0;
}

void buildCuadruple5(int uno, int dos, int tres){
	cuadruplos x;
	x.op = uno;
	x.opdo1 = dos;
	x.opdo2 = tres;
	x.res = -1;
	hasht[cont_cuadruple] = x;
	cont_cuadruple++;
}

void buildCuadrupleM(int a, int b, int c, int d){
	cuadruplos x;
	x.op = a;
	x.opdo1 = b;
	x.opdo2 = c;
	x.res = d;
	hasht[cont_cuadruple] = x;
	cont_cuadruple++;

}

void buildCuadrupleF(int a, int b, int c, int d){
cuadruplos x;
	x.op = a;
	x.opdo1 = b;
	x.opdo2 = c;
	x.res = d;
	hasht[cont_cuadruple] = x;
	PSaltos.push(cont_cuadruple+1);
	PSaltos.push(cont_cuadruple-2);
	cont_cuadruple++;
}

void buildCuadrupleF2(int a, int b, int c, int d){
cuadruplos x;
	x.op = a;
	x.opdo1 = b;
	x.opdo2 = c;
	x.res = d;
	hasht[cont_cuadruple] = x;
	PSaltos.push(cont_cuadruple+1);
	cont_cuadruple++;
}


//genera cuadruplos del for
void buildCuadrupleFOR(){
	int temp, temp2;
	int tipo = PTipos.top();
	PTipos.pop();
	cout << "entro al for" << endl;
		switch(tipo) {
			case 0:
				temp = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				temp2 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
			break;
			case 1:
				temp = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				temp2 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
			break;
			case 2:
				temp = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				temp2 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);				
			break;
			case 3:
				temp = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				temp2 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
			break;
			case 4:
				temp = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				temp2 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
			break;
			default:
				cout << "Type mismatch FOR.." << endl;
		}
cout << "genero temporales" << endl;
	int exp2 = POperandos.top();
	POperandos.pop();
cout << "saco de operandos exp2: " << exp2 << endl;
	cuadruplos x,y,z;

	x.op = 12;
	x.opdo1 = -1;
	x.opdo2 = exp2;
	x.res = temp;

	y.op = 8;
	y.opdo1 = asact;
	y.opdo2 = temp;
	y.res = temp2;

	z.op = GOTOF;
	z.opdo1 = temp2;
	z.opdo2 = -1;
	z.res = -1;

	hasht[cont_cuadruple] = x;
	cont_cuadruple++;

	hasht[cont_cuadruple] = y;
	cont_cuadruple++;

	hasht[cont_cuadruple] = z;
	cont_cuadruple++;
cout << "genero cuadruplos" << endl;
	//Libera temp
	PSaltos.push((cont_cuadruple-2));
}

//Genera cuadruplos para el punto medio.
void buildCuadruplePM(){
	int t1,t2,t3,t4;
	int tipo = PTipos.top();
	PTipos.pop();

		switch(tipo) {
			case 0:
				t1 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t2 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t3 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t4 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);

			break;
			case 1:
				t1 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t2 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t3 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t4 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
			break;
			case 2:
				t1 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t2 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t3 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t4 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);				
			break;
			case 3:
				t1 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t2 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t3 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t4 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
			break;
			case 4:
				t1 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t2 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t3 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t4 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
			break;
			default:
				cout << "Type mismatch PUNTO MEDIO.." << endl;
		}

	cout << "Genero temporales" << endl;
	int y2 = POperandos.top();
	POperandos.pop();
	int x2 = POperandos.top();
	POperandos.pop();
	int y1 = POperandos.top();
	POperandos.pop();
	int x1 = POperandos.top();
	POperandos.pop();

	buildCuadrupleM(0,x1,x2,t1);
	buildCuadrupleM(3,t1,2,t2);
	buildCuadrupleM(0,y1,y2,t3);
	buildCuadrupleM(3,t3,2,t4);
	buildCuadrupleM(24,t2,t4,-1);	
}
//Genera cuadruplos para el punto medio.
void buildCuadrupleDosP(){
	int t1,t2,t3,t4,t5,t6;
	int tipo = PTipos.top();
	PTipos.pop();

		switch(tipo) {
			case 0:
				t1 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t2 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t3 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t4 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t5 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t6 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);

			break;
			case 1:
				t1 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t2 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t3 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t4 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t5 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t6 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
			break;
			case 2:
				t1 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t2 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t3 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t4 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t5 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t6 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);					
			break;
			case 3:
				t1 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t2 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t3 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t4 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t5 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t6 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
			break;
			case 4:
				t1 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t2 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t3 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t4 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t5 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t6 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
			break;
			default:
				cout << "Type mismatch PUNTO MEDIO.." << endl;
		}

	cout << "Genero temporales" << endl;
	int y2 = POperandos.top();
	POperandos.pop();
	int x2 = POperandos.top();
	POperandos.pop();
	int y1 = POperandos.top();
	POperandos.pop();
	int x1 = POperandos.top();
	POperandos.pop();

	buildCuadrupleM(1,x2,x1,t1);
	buildCuadrupleM(POW,t1,2,t2);
	buildCuadrupleM(1,y2,y1,t3);
	buildCuadrupleM(POW,t3,2,t4);
	buildCuadrupleM(0,t2,t4,t5);
	buildCuadrupleM(SQRT,t5,-1,t6);
	buildCuadrupleM(DIST,t6,-1,-1);	
}
//Genera cuadruplos para generar la ecuacion de una recta.
void buildCuadrupleEcu(){
	int t1,t2,t3;
	int tipo = PTipos.top();
	PTipos.pop();

		switch(tipo) {
			case 0:
				t1 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t2 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
				t3 = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);

			break;
			case 1:
				t1 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t2 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				t3 = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
				
			break;
			case 2:
				t1 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t2 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
				t3 = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
					
			break;
			case 3:
				t1 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t2 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				t3 = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
				
			break;
			case 4:
				t1 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t2 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				t3 = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
				
			break;
			default:
				cout << "Type mismatch Ecuacion.." << endl;
		}

	cout << "Genero temporales" << endl;
	int y2 = POperandos.top();
	POperandos.pop();
	int x2 = POperandos.top();
	POperandos.pop();
	int y1 = POperandos.top();
	POperandos.pop();
	int x1 = POperandos.top();
	POperandos.pop();

	buildCuadrupleM(1,y2,y1,t1);
	buildCuadrupleM(1,x2,x1,t2);
	buildCuadrupleM(3,t1,t2,t3);
	buildCuadrupleM(ECU,t1,t2,t3);
}

void buildCuadrupleA(int a, int b, int c) {
int tipo,temp;
tipo=PTipos.top();
switch(tipo) {
			case 0:
				temp = MemTemp.mint;
				MemTemp.mint = MemTemp.insertaInt(MemTemp.mint, 6000, tipo);
			break;
			case 1:
				temp = MemTemp.mfloat;
				MemTemp.mfloat = MemTemp.insertaFloat(MemTemp.mfloat, 7000, tipo);
			break;
			case 2:
				temp = MemTemp.mstring;
				MemTemp.mstring = MemTemp.insertaString(MemTemp.mstring, 8000, tipo);
			break;
			case 3:
				temp = MemTemp.mboolean;
				MemTemp.mboolean = MemTemp.insertaBoolean(MemTemp.mboolean, 9000, tipo);
			break;
			case 4:
				temp = MemTemp.mcomplex;
				MemTemp.mcomplex = MemTemp.insertaComplex(MemTemp.mcomplex, 10000, tipo);
			break;
			default:
				cout << "Type mismatch" << endl;
		}
cuadruplos x;
	x.op = a;
	x.opdo1 = b;
	x.opdo2 = c;
	x.res = temp ;
	hasht[cont_cuadruple] = x;

	POperandos.push(temp);
cout << "Temporal en la primera dimension pila " << POperandos.top() << endl;
	cont_cuadruple++;
}

void buildCuadrupleP(int a, int b, int c) {
int tipo,temp;
tipo=PTipos.top();
switch(tipo) {
			case 0:
				temp = MemPoint.mint;
				MemPoint.mint = MemPoint.insertaInt(MemPoint.mint, 26000, tipo);
			break;
			case 1:
				temp = MemPoint.mfloat;
				MemPoint.mfloat = MemPoint.insertaFloat(MemPoint.mfloat, 27000, tipo);
			break;
			case 2:
				temp = MemPoint.mstring;
				MemPoint.mstring = MemPoint.insertaString(MemPoint.mstring, 28000, tipo);
			break;
			case 3:
				temp = MemPoint.mboolean;
				MemPoint.mboolean = MemPoint.insertaBoolean(MemPoint.mboolean, 29000, tipo);
			break;
			case 4:
				temp = MemPoint.mcomplex;
				MemPoint.mcomplex = MemPoint.insertaComplex(MemPoint.mcomplex, 30000, tipo);
			break;
			default:
				cout << "Type mismatch" << endl;
		}
cuadruplos x;
	x.op = a;
	x.opdo1 = b;
	x.opdo2 = c;
	x.res = temp ;
	hasht[cont_cuadruple] = x;
	POperandos.push(temp);
	cont_cuadruple++;
}


//funcion en donde se imprimen los cuadruplos a un archivo y tambien imprime las tablas de constantes
void printCuadruplos() {

ofstream f1;
ofstream c1;
ofstream c2;
ofstream c3;
ofstream c4;
f1.open ("cuadruplos.matrix");
	for(unordered_map<int, cuadruplos>::iterator it = hasht.begin(); it != hasht.end(); it ++){
	cout << (*it).first << " " << (*it).second.op << " " << (*it).second.opdo1 << " " << (*it).second.opdo2 << " " << (*it).second.res << endl;
	f1 << (*it).first << " " << (*it).second.op << " " << (*it).second.opdo1 << " " << (*it).second.opdo2 << " " << (*it).second.res << endl;
	}
f1.close();


c1.open("int.cte");

	for (int n=0; n<conti; n++){
		//cout << intTable[n].dirV << " " << intTable[n].val;
		c1 << ct.in[n].dirV << " " << ct.in[n].val << endl;	
	}
c1.close();
c2.open("float.cte");
	for (int n=0; n<contf; n++){
		//cout << floatTable[n].dirV << " " << floatTable[n].val;
		c2 << ct.fn[n].dirV << " " << ct.fn[n].val << endl;
	}
c2.close();
c3.open("str.cte");
	for (int n=0; n<conts; n++){
		//cout << stringTable[n].dirV << " " << stringTable[n].val;
		c3 << ct.sn[n].dirV << " " << ct.sn[n].val << endl;
	}
c3.close();
c4.open("bool.cte");
	for (int n=0; n<contb; n++){
		cout << ct.bn[n].dirV << " " << ct.bn[n].val << endl;
		c4 << ct.bn[n].dirV << " " << ct.bn[n].val << endl;	
	}
c4.close();
}

// funcion para reportar error
void Err(wchar_t* msg) {
		errors->Error(la->line, la->col, msg);
}

//la funcion mas importante del compilador en donde se inician las variables con valores ya definidos
void InitDeclarations() { // it must exist
	floats=1; integer=0; boolean=3; complexi=4; stringg = 2;  // types
	plus=0; minus=1; times=2; slash=3; diff=4; gtr=5; lss=6; gtreq=7; lsseq=8; eqeq=9; andop=10; orop=11; equ=12; // operators
	var = 0; def = 1; // object kinds

	cont_cuadruple=1;	
	numdim=0;R=1;st.tempnumarr=1;	
	conti=0;contf=0;contb=0;conts=0;
	dimactual=0;

	// opcodes
	ADD  =  0; SUB   =  1; MUL   =  2; DIV   =  3; DIFF   =  4; GTR = 5; LSS = 6;
	GTREQ = 7; LSSEQ =8; EQEQ =9; ANDOP =10; OROP = 11; EQU = 12; RET = 13; GOTOV = 14;
	GOTOF = 15; GOTO = 16; PARAM= 17; PRINT = 18; RETURN =19; ERA = 20; GOSUB = 21; READ = 22; END = 23; PM = 24; SQRT = 25; POW = 26; DIST = 27; ECU = 28; SIN = 29; CSC = 30; COS = 31; COT = 32; TAN = 33; SEC = 34; VERF=40;
	
	numproc=0;
	MemGlobal.mint = 1000;
	MemGlobal.mfloat = 2000;
	MemGlobal.mstring = 3000;
	MemGlobal.mboolean = 4000;
	MemGlobal.mcomplex = 5000;

	MemTemp.mint = 6000;
	MemTemp.mfloat = 7000;
	MemTemp.mstring = 8000;
	MemTemp.mboolean = 9000;
	MemTemp.mcomplex = 10000;

	MemConst.mint = 11000;
	MemConst.mfloat = 12000;
	MemConst.mstring = 13000;
	MemConst.mboolean = 14000;
	MemConst.mcomplex = 15000;
	
	MemLoc.mint = 20000;
	MemLoc.mfloat = 21000;
	MemLoc.mstring = 22000;
	MemLoc.mboolean = 23000;
	MemLoc.mcomplex = 25000;

	MemPoint.mint = 26000;
	MemPoint.mfloat=27000;
	MemPoint.mstring=28000;
	MemPoint.mboolean=29000;
	MemPoint.mcomplex=30000;
}

// inicia el compilador
CHARACTERS
	under = '_'.
	letter = 'A'..'Z' + 'a'..'z'.
	digit = '0'..'9'.
	cr  = '\r'.
	lf  = '\n'.
	tab = '\t'.
	quote = '"'.
	blash = '\\'.
	anyButQuote = ANY - quote.
	chars = ANY - digit - cr - lf - tab - blash - quote.
TOKENS
	ident = (letter | under) {letter | digit | under}.
	number = digit {digit}.
	flotante = digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}].
	imaginario =  ( digit {digit} '.' {digit} ['E' ['+'|'-'] digit {digit}] | digit {digit} ) ("i" | "I").
	string =  quote { ( chars | digit) } quote.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr lf

IGNORE cr + lf + tab
PRODUCTIONS      

//gramaticas
Ident<wchar_t* &name>= ident (. name = coco_string_create(t->val); .).

matematrix = (. wchar_t* name; InitDeclarations(); .) "program" Ident<name>  (. 
	st.insertaDirProc(numproc,0, name, MemGlobal.mint); 
.) ';'(.
	PSaltos.push(cont_cuadruple);
	buildCuadrupleM(GOTO,-1,-1,-1);
.) [variables] (.
	numproc = numproc+1;
.) [funcion{funcion}] "main" (.
	int goo;
	goo = PSaltos.top();
	PSaltos.pop();
	rellenar(goo,cont_cuadruple);

.) bloque (.
	buildCuadrupleM(END,-1,-1,-1);
	st.printArr();
	st.printLista();
	printCuadruplos();
.).


//funcion = (funcU | funcE).
//funcU = (funcV| funcT).


tipo<int &type> 
= 
("int" (. type = integer; .) | 
"float" (. type = floats; .) | 
"bool" (. type = boolean; .) | 
"string" (. type = stringg; .) | 
"complex" (. type = complexi; .) ).

var_cte (.int n1;float m1;bool b1;wchar_t *s1;.) = ( number (. 
	swscanf(t->val, L"%d", &n1);
	ct.tempconst = MemConst.mint;
	//cout << n1 << " es dirV " << MemConst.mint << endl; 
	MemConst.mint = ct.insertaInt(MemConst.mint,11000,n1);
	ct.constTipo = 0;
	conti++;
.)  | flotante (. 
	swscanf(t->val, L"%f", &m1); 
	ct.tempconst = MemConst.mfloat;
	//cout << m1 << endl;
	MemConst.mfloat = ct.insertaFloat(MemConst.mfloat,12000, m1);
	ct.constTipo = 1;
	contf++;
.) | "true" (. 
	b1 = true;
	ct.tempconst = MemConst.mboolean;
	MemConst.mboolean = ct.insertaBoolean(MemConst.mboolean,14000, b1);
	ct.constTipo = 3;
	contb++;
.) | "false" (. 
	b1 = false; 
	ct.tempconst = MemConst.mboolean;
	MemConst.mboolean = ct.insertaBoolean(MemConst.mboolean,14000, b1);
	ct.constTipo = 3;
	contb++;
.) | string (. 
	s1 = coco_string_create(t->val); 
	ct.tempconst = MemConst.mstring;
	MemConst.mstring = ct.insertaString(MemConst.mstring,13000, s1);
	ct.constTipo = 2;
	conts++;
.)  | imaginario ).

bloque = '{' [ estatuto { estatuto } ] '}'.

index = '[' (.
	dimactual = 0;
	cout << "Temp Vardim " << st.tempdim << endl;
	if (st.tempdim != -1) {
		idArr = POperandos.top(); POperandos.pop();
		PDimensiones.push(idArr);	
		POperadores.push(-999);
		templlave=st.tempdim;
		tempbase=st.tempdir;
		st.tempdimfinal = st.getDim(templlave);
		cout << "dimensiones" << st.tempdimfinal<< endl;
	}

.) exp (. 
	int res, sup;
	dimactual++;
	res=POperandos.top();
	//cout << "Llave " << templlave<< endl;
	//cout<< "dim actual " << dimactual << endl;
	sup=st.dameSup(templlave, dimactual);
	buildCuadrupleM(VERF, res, 0, sup);
.)']'(.
	int aux, aux1, aux2,M, base;
	if (dimactual < st.tempdimfinal){ 
		cout << "True if arreglo dim 1" << endl;
		aux=POperandos.top();	
		M=st.dameM(templlave,dimactual);
		buildCuadrupleA(MUL, aux, M);

/*
else if (dimactual > 1) {
	aux2=POperandos.top();POperandos.pop();
	aux1=POperandos.top();POperandos.pop();
	buildCuadrupleA(ADD, aux1, aux2);
}
*/
} else {
	aux1=POperandos.top(); POperandos.pop();
	buildCuadrupleA(ADD, aux1, 0);
	base=tempbase;
	buildCuadrupleP(ADD,POperandos.top(),base);
	POperadores.pop();
	PDimensiones.pop();
}
.) {  '[' (.

	//idArr = POperandos.top(); POperandos.pop();
	PDimensiones.push(idArr);	
	POperadores.push(-999);
.) exp (. 
	int res, sup;
	dimactual++;
	res=POperandos.top();
	cout << "Llave " << templlave<< endl;
	cout<< "dim actual " << dimactual << endl;
	sup=st.dameSup(templlave, dimactual);
	buildCuadrupleM(VERF, res, 0, sup);
.) ']' (.
	int aux, aux1, aux2,M, base;
	cout<< "dim actual!!! " << dimactual << endl;
	if (dimactual < st.tempdimfinal){ 
	cout << "+1 dimension if checanulo " << endl;
	aux=POperandos.top();
	M=st.dameM(templlave,dimactual);
	buildCuadrupleA(MUL, aux, M);
} else if (dimactual > 1) {
	cout << "entro a dimactual mayor a 1" << endl;
	aux2=POperandos.top();POperandos.pop();
	aux1=POperandos.top();POperandos.pop();
	buildCuadrupleA(ADD, aux1, aux2);
		aux1=POperandos.top(); POperandos.pop();
		buildCuadrupleA(ADD, aux1, 0);
		base=tempbase;
		buildCuadrupleP(ADD,POperandos.top(),base);
		POperadores.pop();
		PDimensiones.pop();
}

.)  }.

estatuto = ( condicion | escritura | lectura | ciclo | funciones | variables | asignacion | returnF ).
returnF = "return" '(' exp ')' (.
int res;
wchar_t* a;
cout << "HERE " << POperandos.top() << endl;
a = PFunciones.top();
res= st.buscaVariable(numproc,a);
buildCuadrupleM(RETURN,-1, POperandos.top(),res);
PFunciones.pop();
.) ';'.
//llamadas = '(' (  funciones  | otras ) ')' .
//otras = Ident<name> [index] ( asignacion | aesp ).
//aesp = ("++" | "--" | "+=" expresion | "-=" expresion ).
//llamadaFuncU = (. wchar_t* name; .)  Ident<name> '(' exp { ',' exp } ')' ';'.	
funciones = '<' ( funcN | funcE ) '>'.

funcN = (. wchar_t* name; .)  Ident<name> (.
int a;
a = st.buscaVariable (0,name);
POperandos.push(a);
cout << POperandos.top() << endl;
		if ( st.checaDirProc2(name)) {
 			st.tempnumproc = st.checaDirProc3(name);
 		}
 .)'(' (.
 		buildCuadrupleM(ERA,-1,-1,-1);
cout << "Hace cuadruplo era" << endl;
 		k=1;
 .) expresion (.
 		arg = POperandos.top();
 		POperandos.pop();
 		tipoarg = PTipos.top();
 		PTipos.pop();
		int tempk;
 		st.temptipop = st.verificaParametro(st.tempnumproc,k);
 		if( st.temptipop == tipoarg && st.temptipop != -1 ) {
			tempk =  st.returnParamK(st.tempnumproc, k);
 			buildCuadrupleM(PARAM,arg,-1,tempk);
 		}
 .) { ',' (.k=k+1;.) expresion (.
 		arg = POperandos.top();
 		POperandos.pop();
 		tipoarg = PTipos.top();
 		PTipos.pop();
		int tempk;
 		st.temptipop = st.verificaParametro(st.tempnumproc, k);
 		if( st.temptipop == tipoarg && st.temptipop != -1 ) {
			tempk =  st.returnParamK(st.tempnumproc, k);
 			buildCuadrupleM(PARAM,arg,-1,tempk);
 		}
 .) } ')' (.
			int tempnp;
			tempnp = st.buscaDirInicio(st.tempnumproc);
 			buildCuadrupleM(GOSUB,tempnp,-1,-1);
cout << "sale de funciones" << endl;
.).

funcE = ( fAlgebra | fMatrix | fGraph | fVector | fTrigonom | log ).
llamadaFuncE = (fTrigonom | log).
variables = "var" ( vares | varns ) { ( vares | varns ) } "end".
vares = ( vector | matriz ).
matriz = (. wchar_t* name;int type; .)  "matrix" tipo<type> Ident<name> '['expresion ',' expresion ']' '=' '(' '[' expresion { ',' expresion } ']' { ',' '[' expresion { ',' expresion } ']' } ')' ';'.
vector = (. wchar_t* name;int type; .)  "vector" tipo<type> Ident<name> '=' '{' expresion ',' expresion ',' expresion '}' ';'.
varns = (. wchar_t* name;int type; .)  tipo<type> Ident<name> (. 

	switch(numproc){
	case 0:
	if( st.checaTablaVars(numproc, type, name) ){
		switch(type) {
			case 0:
				MemGlobal.mint = st.newTablaVar(numproc, type, name, MemGlobal.mint);
			break;
			case 1:
				MemGlobal.mfloat = st.newTablaVar(numproc, type, name, MemGlobal.mfloat);
			break;
			case 2:
				MemGlobal.mstring = st.newTablaVar(numproc, type, name, MemGlobal.mstring);
			break;
			case 3:
				MemGlobal.mboolean = st.newTablaVar(numproc, type, name, MemGlobal.mboolean);
			break;
			case 4:
				MemGlobal.mcomplex = st.newTablaVar(numproc, type, name, MemGlobal.mcomplex);
			break;
			default:
				MemGlobal.mint = st.newTablaVar(numproc, type, name, MemGlobal.mint);
		}
	}
	break;
	default:

	if( st.checaTablaVars(numproc, type, name) ){
		switch(type) {
			case 0:
				MemLoc.mint = st.newTablaVar(numproc, type, name, MemLoc.mint);
			break;
			case 1:
				MemLoc.mfloat = st.newTablaVar(numproc, type, name, MemLoc.mfloat);
			break;
			case 2:
				MemLoc.mstring = st.newTablaVar(numproc, type, name, MemLoc.mstring);
			break;
			case 3:
				MemLoc.mboolean = st.newTablaVar(numproc, type, name, MemLoc.mboolean);
			break;
			case 4:
				MemLoc.mcomplex = st.newTablaVar(numproc, type, name, MemLoc.mcomplex);
			break;
			default:
				MemLoc.mint = st.newTablaVar(numproc, type, name, MemLoc.mint);
		}
	}

}
.) ['['(.
numdim=0;
	R = 1;
	st.agregaDim(numproc,st.tempnumarr, name); 
	numdim++; 
.) number(.
	int n1;
	swscanf(t->val, L"%d", &n1);
	if (n1 < 1) {
		(L"La constante debe ser mayor que 0.");
	} else { 	
st.newTablaDesc(numproc,0,n1-1,-1,st.tempnumarr);
		//st.almacenaConsArr(st.tempnumarr,numdim,n1-1);
		R = n1* R;	
		PDimensiones.push(n1);
	}
.)
']'{'[' (. 
	numdim++; 
.)number(.
	int n1;
	swscanf(t->val, L"%d", &n1);
	if (n1 < 1) {
		(L"La constante debe ser mayor que 0.");
	} else { 
		st.newTablaDesc(numproc,0,n1-1,-1,st.tempnumarr);
		//st.almacenaConsArr(st.tempnumarr,numdim,n1-1);	
		R = n1*R;	
		PDimensiones.push(n1);
		PDimensiones.push(n1);
	}
.)']'} (.

	m = (int *) malloc (numdim * sizeof(int)); 
	m = new int [numdim];
	int K;
	K = st.loopDim(R,numdim,m,st.tempnumarr);
	free(m); 
	switch(numproc){
	case 0:
		switch(type) {
			case 0:
				MemGlobal.mint = MemGlobal.mint + K;
			break;
			case 1:
				MemGlobal.mfloat = MemGlobal.mfloat + K;
			break;
			case 2:
				MemGlobal.mstring = MemGlobal.mstring + K;
			break;
			case 3:
				MemGlobal.mboolean = MemGlobal.mboolean + K;
			break;
			case 4:
				MemGlobal.mcomplex = MemGlobal.mcomplex + K;
			break;
			default:
				MemGlobal.mint = MemGlobal.mint + K;
		}
	break;
	default:
		switch(type) {
			case 0:
				MemLoc.mint = MemLoc.mint + K;
			break;
			case 1:
				MemLoc.mfloat = MemLoc.mfloat + K;
			break;
			case 2:
				MemLoc.mstring = MemLoc.mstring + K;
			break;
			case 3:
				MemLoc.mboolean = MemLoc.mboolean + K;
			break;
			case 4:
				MemLoc.mcomplex = MemLoc.mcomplex + K;
			break;
			default:
				MemLoc.mint = MemLoc.mint + K;
		}
	}
st.tempnumarr+=1;
 .) ] 
/*
PDimensiones.top();
Lsdim=PDimensiones.top()-1;
//PDimensiones.pop();
Lidim=0;
*/
['=' exp1] ';'. //[index] ( [asignacion] | ';'). 


eqOp<int &op> = (. op = -1; .) '=' (. op = equ;.) .

//ASIGNACION
asignacion = (.int op; wchar_t* name; .)  Ident<name> (.
	asact = st.buscaVariable(numproc, name);
	//cout << " tu as dir es " << asact <<endl;
	POperandos.push(asact);
	PTipos.push(st.temptipo);

.) [ index ] eqOp<op> (.
	POperadores.push(op);
.) expresion (. cout << POperadores.top() << endl;	
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == equ){
			buildCruadruple2(POperadores.top());
cout << "hace cuadruplo asignacion" << endl;	
		}
	}
.) ';'.
//EXPRESION
expresion = (.int op; .) exp (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == andop || POperadores.top() == orop) {
			buildCruadruple(POperadores.top());
		}
	} 
.)
{ boolOp<op> (.
	POperadores.push(op);
.)
exp }.

boolOp<int &op> = (. op = -1; .) ( "and"  (. op = andop; .)  | "or"  (. op = orop; .) ). 

exp = (.int op; .)  exp1 [ relOp<op> (.
	POperadores.push(op);
.) exp1 (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == gtr || POperadores.top() == lss || POperadores.top() == diff || POperadores.top() == eqeq || POperadores.top() == lsseq || POperadores.top() == gtreq ) {
//cout << "Entro a hacer cuadruplo... comparacion" << endl;
			buildCruadruple(POperadores.top());
		}
	} 
.) ].

relOp<int &op> = (. op = -1; .)
( '>' (. op = gtr; .) | 
'<' (. op = lss; .) | 
"<>" (. op = diff; .) | 
"==" (. op = eqeq; .) | 
"<=" (. op = lsseq; .) | 
">="  (. op = gtreq; .) ). 

exp1 = (.int op;.) termino (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == plus || POperadores.top() == minus) {
			buildCruadruple(POperadores.top());
		}
	} .) { addOp<op> (.cout<<"op es: " << op << endl; POperadores.push(op);.)  termino (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == plus || POperadores.top() == minus) {
			buildCruadruple(POperadores.top());
		}
	} .)
}.

addOp<int &op> = (. op = -1; .) ( '+' (. op = plus; .) | '-' (. op = minus; .)). 

termino = (.int op;.)  factor (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == slash || POperadores.top() == times) {
			buildCruadruple(POperadores.top());
		}
	} 
.) { mulOp<op> (.
	POperadores.push(op);
.) factor (.
	if ( !POperadores.empty() ) {
		if ( POperadores.top() == slash || POperadores.top() == times) {
			buildCruadruple(POperadores.top());
		}
	} 
.) }.	

mulOp<int &op> = (. op = -1; .) ( '*' (. op = times; .) | '/' (. op = slash; .) ). 

factor = (. wchar_t* name; .)  ( Ident<name> (.
	diract = st.buscaVariable(numproc, name);
	//cout << " tu dir es " << diract <<endl;
	POperandos.push(diract);
	PTipos.push(st.temptipo);

.)
[ ( index  | '(' expresion ')' ) ]| llamadaFuncE | funciones | var_cte (.

	POperandos.push(ct.tempconst);
	PTipos.push(ct.constTipo);

.) | '(' (. POperadores.push(-9999); .) exp')' (. 
	if( POperadores.top() == -9999) {
		POperadores.pop(); 
	} else {
	cout << "error" << endl;
	}
.) ).

funcion = "def" (funcV | funcT) '('[parametros]')' (.
	if (numproc != 0) {
		st.insertaContDirProc(numproc, cont_cuadruple);
	}
.) bloque (.
	buildCuadrupleM(RET,-1,-1,-1);	
	numproc = numproc+1;
.).

funcV = (. wchar_t* name;int type; .) "void" (. tipo_proc=-1 ; .) Ident<name>  (.
	if( st.checaDirProc(numproc, tipo_proc, name) ){
		st.insertaDirProc(numproc, tipo_proc, name,MemLoc.mint);
	}
.).

funcT = (. wchar_t* name;int type; .)  tipo<type> (. tipo_proc = type; .) Ident<name>  (.
PFunciones.push(name);
	if( st.checaDirProc(numproc, tipo_proc, name) ){
		switch(type){
			case 0:
			MemLoc.mint = st.newDirProc(numproc, tipo_proc, name, MemLoc.mint);
			break;
			case 1:
			MemLoc.mfloat = st.newDirProc(numproc, tipo_proc, name, MemLoc.mfloat);
			break;
			case 2:
			MemLoc.mstring = st.newDirProc(numproc, tipo_proc, name, MemLoc.mstring);
			break;
			case 3:
			MemLoc.mboolean = st.newDirProc(numproc, tipo_proc, name, MemLoc.mboolean);
			break;
			case 4:
			MemLoc.mcomplex = st.newDirProc(numproc, tipo_proc, name, MemLoc.mcomplex);
			break;
			default:
			MemLoc.mint = st.newDirProc(numproc, tipo_proc, name, MemLoc.mint);
		}
	}
switch(type) {
			case 0:
				MemGlobal.mint = st.newTablaVar(0, type, name, MemGlobal.mint);
			break;
			case 1:
				MemGlobal.mfloat = st.newTablaVar(0, type, name, MemGlobal.mfloat);
			break;
			case 2:
				MemGlobal.mstring = st.newTablaVar(0, type, name, MemGlobal.mstring);
			break;
			case 3:
				MemGlobal.mboolean = st.newTablaVar(0, type, name, MemGlobal.mboolean);
			break;
			case 4:
				MemGlobal.mcomplex = st.newTablaVar(0, type, name, MemGlobal.mcomplex);
			break;
			default:
				MemGlobal.mint = st.newTablaVar(0, type, name, MemGlobal.mint);
		}


.).

parametros = (. wchar_t* name; int type; .)  tipo<type> Ident<name> (. 

switch(numproc){
case 0:
if( st.checaTablaParam(numproc, type, name) ){
	switch(type) {
		case 0:
			MemGlobal.mint = st.newTablaParam(numproc, type, name, MemGlobal.mint);
		break;
		case 1:
			MemGlobal.mfloat = st.newTablaParam(numproc, type, name, MemGlobal.mfloat);
		break;
		case 2:
			MemGlobal.mstring = st.newTablaParam(numproc, type, name, MemGlobal.mstring);
		break;
		case 3:
			MemGlobal.mboolean = st.newTablaParam(numproc, type, name, MemGlobal.mboolean);
		break;
		case 4:
			MemGlobal.mcomplex = st.newTablaParam(numproc, type, name, MemGlobal.mcomplex);
		break;
		default:
			MemGlobal.mint = st.newTablaParam(numproc, type, name, MemGlobal.mint);
	}
}
break;
default:

if( st.checaTablaParam(numproc, type, name) ){
	switch(type) {
		case 0:
			MemLoc.mint = st.newTablaParam(numproc, type, name, MemLoc.mint);
		break;
		case 1:
			MemLoc.mfloat = st.newTablaParam(numproc, type, name, MemLoc.mfloat);
		break;
		case 2:
			MemLoc.mstring = st.newTablaParam(numproc, type, name, MemLoc.mstring);
		break;
		case 3:
			MemLoc.mboolean = st.newTablaParam(numproc, type, name, MemLoc.mboolean);
		break;
		case 4:
			MemLoc.mcomplex = st.newTablaParam(numproc, type, name, MemLoc.mcomplex);
		break;
		default:
			MemLoc.mint = st.newTablaParam(numproc, type, name, MemLoc.mint);
	}
}


}




.)
{ ',' 
tipo<type> Ident<name> 
(. 
switch(numproc){
case 0:
if( st.checaTablaParam(numproc, type, name) ){
	switch(type) {
		case 0:
			MemGlobal.mint = st.newTablaParam(numproc, type, name, MemGlobal.mint);
		break;
		case 1:
			MemGlobal.mfloat = st.newTablaParam(numproc, type, name, MemGlobal.mfloat);
		break;
		case 2:
			MemGlobal.mstring = st.newTablaParam(numproc, type, name, MemGlobal.mstring);
		break;
		case 3:
			MemGlobal.mboolean = st.newTablaParam(numproc, type, name, MemGlobal.mboolean);
		break;
		case 4:
			MemGlobal.mcomplex = st.newTablaParam(numproc, type, name, MemGlobal.mcomplex);
		break;
		default:
			MemGlobal.mint = st.newTablaParam(numproc, type, name, MemGlobal.mint);
	}
}
break;
default:

if( st.checaTablaParam(numproc, type, name) ){
	switch(type) {
		case 0:
			MemLoc.mint = st.newTablaParam(numproc, type, name, MemLoc.mint);
		break;
		case 1:
			MemLoc.mfloat = st.newTablaParam(numproc, type, name, MemLoc.mfloat);
		break;
		case 2:
			MemLoc.mstring = st.newTablaParam(numproc, type, name, MemLoc.mstring);
		break;
		case 3:
			MemLoc.mboolean = st.newTablaParam(numproc, type, name, MemLoc.mboolean);
		break;
		case 4:
			MemLoc.mcomplex = st.newTablaParam(numproc, type, name, MemLoc.mcomplex);
		break;
		default:
			MemLoc.mint = st.newTablaParam(numproc, type, name, MemLoc.mint);
	}
}

}
.) }.

ciclo = (ciclofor | ciclowhile).

condicion = "if" '(' expresion ')'  (. 
	int aux;
	aux=PTipos.top();
	if (aux == 3){
//cout << "entra a hacer cuadruplo condicion" << endl;
		buildCuadruple4(POperandos.top());
		PSaltos.push((cont_cuadruple-1));
	} else {
		cout << "Semantic error: Type mismatch" << endl;
	}
.)
bloque ["elif" '(' expresion ')' (. 
	int aux;
	aux=PTipos.top();
	if (aux == 3){
		buildCuadruple4(POperandos.top());
	} else {
	cout << "Semantic error: Type mismatch" << endl;
	}
.) bloque { "elif" '(' expresion ')' bloque } ] [ "else" (. 
	int salto;
	buildCuadruple5(GOTO,-1,-1);
	salto = PSaltos.top();
	PSaltos.pop();
	rellenar(salto, cont_cuadruple);
	PSaltos.push((cont_cuadruple-1));

//cout << "En psaltos despues de cuadruplo5 " << PSaltos.top() << endl;
//cout << cont_cuadruple << endl;

.)
bloque ] (.
	int sss;
	sss = PSaltos.top();
	PSaltos.pop();
	rellenar(sss, cont_cuadruple);
.).

//Acciones para generar cuadruplos de WHILE
ciclowhile = "while" (. 
	//cout << "entro al while" << endl;
	PSaltos.push(cont_cuadruple); 
.) '(' expresion ')' (.
	buildCuadruple3();
.) bloque (. 
	buildCuadrupleWhile();
.).
	//Acciones para generar cuadruplos de FOR
ciclofor = (. wchar_t* name; .)  "for" '(' asignacion expresion(.
	llenar1=0; llenar2=0; llenar3=0; llenar4=0;
	//buildCuadrupleFOR();
	tempfor=asact;
	cout << "TemporalFOR " << tempfor << endl;
	buildCuadrupleM(GOTOF,POperandos.top(),-1,-1);
	llenar1=cont_cuadruple-1;
	buildCuadrupleF(GOTO,-1,-1,-1);
	llenar2=cont_cuadruple-1;
	ct.tempconst = MemConst.mint;
	//cout << n1 << " es dirV " << MemConst.mint << endl; 
	MemConst.mint = ct.insertaInt(MemConst.mint,11000,1);
	conti++;	
	buildCuadrupleM(ADD,tempfor,ct.tempconst,tempfor);
	//buildCuadrupleI();
	buildCuadrupleF2(GOTO,-1,-1,-1);
	llenar3=cont_cuadruple-1;
.) ')' bloque (.
	//cout << "salio bloque" << endl;
	buildCuadrupleF2(GOTO,-1,-1,-1);
	llenar4=cont_cuadruple-1;
	rellenar(llenar1,PSaltos.top());
	PSaltos.pop();
	rellenar(llenar2,PSaltos.top());
	PSaltos.pop();
	rellenar(llenar3,PSaltos.top());
	PSaltos.pop();
	rellenar(llenar4,PSaltos.top());
	PSaltos.pop();

/*
	buildCuadrupleM(ADD,tempfor,1,tempfor);
	int retorno = PSaltos.top();
	PSaltos.pop();
	buildCuadrupleM(GOTO,-1,-1,retorno);

	rellenar((retorno+1), cont_cuadruple);
*/
.) .
//Acciones para generar cuadruplos de de escritura (WRITE)
escritura = "print" '(' exp (.
	//cout << "entro al print" << endl;
	int resul = POperandos.top();
	POperandos.pop();
	cout << "pop : " << resul << endl;
	buildCuadrupleM(PRINT,resul,-1,-1);
	cout << "creo cuadruplo print" << endl;
.){ ',' exp(.
	cout << "entro al print" << endl;
	int resul = POperandos.top();
	POperandos.pop();
	cout << "pop : " << resul << endl;
	buildCuadrupleM(PRINT,resul,-1,-1);
	cout << "creo cuadruplo print" << endl;
.) } ')'  ';'.

//Acciones para generar cuadruplos de de escritura (READ)
lectura = (. wchar_t* name; .)  "read" '(' Ident<name> ')' (.	
	int idread = st.buscaVariable(numproc, name);
	cout << " id de read: " << idread <<endl;
	POperandos.push(idread);

	cout << "entro al READ" << endl;
	int resulr = POperandos.top();
	POperandos.pop();
	cout << "pop : " << resulr << endl;
	buildCuadrupleM(READ,resulr,-1,-1);
	cout << "creo cuadruplo READ" << endl;
.)';'.

Sum_V = "sum_v" '(' expresion { ',' expresion } ')' ';'.
Mul_V = "mul_v" '('  expresion { ',' expresion } ')' ';'.
pro_ev = "pro_ev" '(' expresion ',' expresion ')' ';'.
Sum_M = (. wchar_t* name; .)  "sum_m" '(' Ident<name> '+' Ident<name> ')' ';'.
Inv_M = "inv_m" '(' expresion ')' ';'.
Mul_M = "mul_m" '(' expresion ',' expresion ')' ';'.
Trans_M = "trans_m" '(' expresion ')' ';'.
//PUNTO MEDIO
punto_medio = "p_m" '(' expresion ',' expresion ',' expresion ',' expresion (. 
	cout << "entro a la expresion final" << endl;
	buildCuadruplePM();
.) ')'.
//Distancia entre 2 puntos
dist_2puntos = "dist_2" '(' expresion ',' expresion ',' expresion ',' expresion (.
	buildCuadrupleDosP();
.) ')'.
//Ecuacion de linea recta
rec_entre_2puntos = "rec_pp" '(' expresion ',' expresion ',' expresion ',' expresion (. 
	buildCuadrupleEcu();
.)')'.

trigoOp<int &op> = (. op = -1; .)
( "sin" (. op = SIN; .) | 
"csc" (. op = CSC; .) | 
"cos" (. op = COS; .) | 
"cot" (. op = COT; .) | 
"tan" (. op = TAN; .) | 
"sec"  (. op = SEC; .) ). 	

fGraph = "graph" '(' exp1 ')'.
fTrigonom = (.int op;.) trigoOp<op> '(' expresion (.
	int resultado = POperandos.top();
	POperandos.pop();
	buildCuadrupleM(op,resultado,-1,-1);
.) ')'.
log = ( 'E' | "log" | "ln" ) '(' expresion ')'.
fAlgebra = ( punto_medio | dist_2puntos | rec_entre_2puntos ).
fMatrix = ( Sum_M | Inv_M | Mul_M | Trans_M).
fVector = ( Sum_V | Mul_V | pro_ev ).

END matematrix. 
